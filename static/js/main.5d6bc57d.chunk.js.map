{"version":3,"sources":["components/GameControls/GameControls.js","components/ColorPicker/ColorPicker.js","components/GridBoard/GridBoard.js","components/GameInstructions/GameInstructions.js","components/Graph/Graph.js","App.js","serviceWorker.js","index.js"],"names":["GameControls","movesCounter","startClicked","className","onClick","ColorPicker","colors","colorFill","incrementCount","useState","active","setActive","map","color","index","key","ColorClicked","GridBoard","grid","rows","nodes","Object","keys","v","classString","size","colorIndexFirstCell","values","every","item","alert","checkIfGameOver","GameInstructions","COLORS","randomIndexFromCollection","collection","i","max","length","Math","random","Node","id","this","Edge","sourceId","destId","weight","Graph","edgesByNode","setEdgeWeights","nodeId","edges","topIndex","rightIndex","bottomIndex","leftIndex","w","sameColor","push","forEach","setEdgeWeight","seenIds","processing","updateEdgeWeights","currentNodeId","pop","updateColor","edge","indexOf","nodeAId","nodeBId","App","setMovesCounter","graph","setGraph","colorIndex","prevState","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.5d6bc57d.chunk.js","sourcesContent":["import React from 'react'\n\nimport './GameControls.css'\n\nconst GameControls = ({movesCounter, startClicked}) => {\n  return (\n    <div className=\"game-controls\">\n      <h1>Color Game</h1>\n      <button onClick={startClicked} className=\"new-game-button\">New Game</button>\n      <div className=\"moves-counter\">Moves : {movesCounter}</div>\n    </div>\n  )\n}\n\nexport default GameControls","import React, {useState} from 'react'\n\nimport './ColorPicker.css'\n\nconst ColorPicker = ({colors, colorFill, incrementCount}) => {\n  const [active, setActive] = useState()\n\n  const ColorClicked = (index, color) => {\n    setActive(index)\n    colorFill(color)\n    incrementCount()\n  }\n\n  return (\n    <div className=\"color-picker\">\n      {colors.map((color, index) => (\n      <div \n        key={index} \n        onClick={() => ColorClicked(index, color)} \n        className={`picker ${color} ${active === index ? 'active': ''}`}>\n      </div>\n    ))}\n    </div>\n  )\n}\n\nexport default ColorPicker","import React from 'react'\n\nimport './GridBoard.css'\n\nconst GridBoard = ({grid, colors}) => {\n  const checkIfGameOver = () => {\n    let colorIndexFirstCell = grid.nodes[0].color;\n    let nodesArray = Object.values(grid.nodes)\n    let isGameComplete = nodesArray.every((item) => item.color === colorIndexFirstCell)\n\n    if(isGameComplete) {\n      alert('Game Over')\n    }\n  }\n\n  let rows = <div> No grid data</div>\n  \n  if(grid.nodes) {\n    rows = Object.keys(grid.nodes).map((v) => {\n      let color = colors[grid.nodes[v].color]\n      let size = grid.size\n      let classString = \"cell-\" + size + \" \" + color;\n  \n      return <div key={v} className={classString}></div>\n    });\n    checkIfGameOver()\n  }\n\n  return (\n    <div className=\"grid-board\">\n      {rows}\n    </div>\n  )\n}\n\nexport default GridBoard","import React from 'react'\n\nimport './GameInstructions.css'\n\nfunction GameInstructions() {\n  return (\n    <ol className=\"instructions\">\n      <li>The goal of the game is to convert all the cells to single color</li>\n      <li>The game starts from top-left (first) cell</li>\n      <li>Click on the colored circle in pallette to change the color of first cell</li>\n      <li>All the adjoning cells with same color will merge</li>\n      <li>Continue step 3 until the game ends</li>\n    </ol>\n  )\n}\n\nexport default GameInstructions\n","const COLORS = [0,1,2,3,4,5,6]; // TODO: tie this together with the COLORS from App.js\n\nconst randomIndexFromCollection = (collection) => {\n  var index = 0;\n  for (var i = 1, max = collection.length; i < max; i++) {\n    if (Math.random() < 1/(i+1)) {\n      index = i;\n    }\n  }\n  return index;\n}\n\nclass Node {\n  constructor(id, color) {\n    this.id = id;\n    this.color = color;\n  }\n}\n\nclass Edge {\n  constructor(sourceId, destId, weight) {\n    this.sourceId = sourceId;\n    this.destId = destId;\n    this.weight = weight;\n  }\n}\n\nclass Graph {\n  constructor(size=3) {\n    this.size = size;\n    this.nodes = {};\n    this.edgesByNode = {};\n    for (let i=0; i<size*size; i++) {\n      this.nodes[i] = new Node(i, randomIndexFromCollection(COLORS));\n    }\n    this.setEdgeWeights();\n  }\n\n  setEdgeWeight(id) {\n      let node = this.nodes[id];\n      let nodeId = node.id;\n\n      // if i subtract the width of my box and i'm < 0 i don't have a top\n      // if i add one and mod myself with the width of my box and i am 0 i don't have a right\n      // if i add the width of my box and i am > width * width - 1 i don't have a bottom\n      // if i mod myself the width of my box and it is 0 i don't have a left\n      \n      let edges = [];\n\n      let topIndex = nodeId - this.size;\n      let rightIndex = nodeId + 1;\n      let bottomIndex = nodeId + this.size;\n      let leftIndex = nodeId - 1;\n\n      if (topIndex >= 0) {\n        let w = this.sameColor(nodeId, topIndex) ? 0 : 1;\n        edges.push(new Edge(nodeId, topIndex, w));\n      }\n\n      if (rightIndex % this.size > 0) {\n        let w = this.sameColor(nodeId, rightIndex) ? 0 : 1;\n        edges.push(new Edge(nodeId, rightIndex, w));\n      }\n\n      if (bottomIndex < this.size * this.size) {\n        let w = this.sameColor(nodeId, bottomIndex) ? 0 : 1;\n        edges.push(new Edge(nodeId, bottomIndex, w));\n      }\n\n      if (nodeId % this.size !== 0) {\n        let w = this.sameColor(nodeId, leftIndex) ? 0 : 1;\n        edges.push(new Edge(nodeId, leftIndex, w));\n      }\n\n      this.edgesByNode[nodeId] = edges;\n  }\n\n  setEdgeWeights() {\n    Object.keys(this.nodes).forEach((id) => {\n      this.setEdgeWeight(id);\n    });\n  }\n\n  updateColor(id, color) {\n    this.nodes[id].color = color;\n  }\n\n  colorFill(color) {\n    let seenIds = [];\n    let processing = [0]; // starting at the top left corner (this is a stack)\n    let updateEdgeWeights = [];\n    while (processing.length > 0) {\n      let currentNodeId = processing.pop();\n      this.updateColor(currentNodeId, color);\n      seenIds.push(currentNodeId);\n      this.edgesByNode[currentNodeId].forEach((edge) => {\n        if (seenIds.indexOf(edge.destId) > -1) {\n          return;\n        }\n        if (edge.weight === 0) {\n          processing.push(edge.destId); // process it there is no weight cost\n        }\n        if (edge.weight === 1 && this.nodes[currentNodeId].color === color) {\n          updateEdgeWeights.push(currentNodeId); // update the edge weights after we finish color filling\n        }\n      });\n    }\n    updateEdgeWeights.forEach((nodeId) => this.setEdgeWeight(nodeId));\n  }\n\n  sameColor(nodeAId, nodeBId) {\n    return this.nodes[nodeAId].color === this.nodes[nodeBId].color;\n  }\n}\n\nexport { Graph }","import React, {useState} from 'react';\n\nimport GameControls from './components/GameControls/GameControls'\nimport ColorPicker from './components/ColorPicker/ColorPicker'\nimport GridBoard from './components/GridBoard/GridBoard'\nimport GameInstructions from './components/GameInstructions/GameInstructions'\nimport { Graph } from './components/Graph/Graph';\n\nimport './App.css';\n\nconst SIZE = 10;\nconst COLORS = ['violet', 'indigo', 'blue', 'green', 'yellow', 'orange', 'red']\n\nfunction App() {\n  const [movesCounter, setMovesCounter] = useState(0)\n  const [graph, setGraph] = useState(new Graph(SIZE))\n\n  const incrementCount = () => {\n    setMovesCounter(prevState => prevState + 1)\n  }\n  \n  const startClicked = () => {\n    setGraph(new Graph(SIZE))\n    setMovesCounter(0)\n  }\n\n  const colorFill = (color) => {\n    let colorIndex = COLORS.indexOf(color)\n    graph.colorFill(colorIndex);\n  }\n\n  return (\n    <div className=\"App\">\n      <GameControls movesCounter={movesCounter} startClicked={startClicked}></GameControls>\n      <GameInstructions></GameInstructions>\n      <ColorPicker colors={COLORS} colorFill={colorFill} incrementCount={incrementCount}></ColorPicker>\n      <GridBoard grid={graph} colors={COLORS} size={SIZE}></GridBoard>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}